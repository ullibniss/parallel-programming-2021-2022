# Федоров Алексей Б19-505

## Домашне задание 3.5: Моделирование построения минимального остова с использованием алгоритмов Прима и Крускала.

### Матрица графа
||||||||
|-|-|-|-|-|-|-|
|-|12|10|∞|11|∞|18|
|12|-|13|14|∞|∞|7|
|10|13|-|9|13|∞|16|
|∞|14|9|-|15|14|∞|
|11|∞|13|15|-|15|14|
|∞|∞|∞|14|15|-|9|
|18|7|16|∞|14|∞|-|

### Граф

![image](https://user-images.githubusercontent.com/55274498/138594049-348fc581-df75-499b-b865-176f2c3db4ed.png)

Минимальное остовное дерево-это остовное дерево графа, имеющее минимальный возможный вес.

### Алгоритм Прима

![image](https://user-images.githubusercontent.com/55274498/138594067-931aac59-fa9b-45bd-aaf7-18a1a7f4acf5.png)

#### Объяснение алгоритма: 
Вначале берется произвольная вершина графа (для определенности в нашем графе возьмем вершину 1). Затем находим вершину, которая соединена с этой вершиной ребром с минимальным весом. Далее ищем еще не обработанную вершину, которая соединена ребром с этим остовом и при этом ребро имеет минимальный вес среди остальных претендентов. Добавляем эту вершину в остов. И так далее до тех пор, пока все вершины графа не будут присоединены к остову. Этот остов и будет минимальным.


### Моделирование алгоритма:

1. Выбираем вершину 1:

![image](https://user-images.githubusercontent.com/55274498/138594138-be687ede-319c-41f9-a141-4f5c3db93d4c.png)

2. Она соединена с вершинами 2, 3, 5, 7. Удовлетворяет критерию вершина 3. Добавляем ее в остов:

![image](https://user-images.githubusercontent.com/55274498/138594157-e0c12313-6608-41a7-88b6-d6ef8dda57ac.png)

3. Следующая вершина, которая удовлетворяет критерию, 4:

![image](https://user-images.githubusercontent.com/55274498/138594165-a17c53dd-3365-4f81-817f-a6e0b0cf9e93.png)

4. Далее с остовом соединена ребром минимального веса вершина 5:

![image](https://user-images.githubusercontent.com/55274498/138594197-4f991a68-4a26-4aa5-ba5d-235b6dc5132b.png)

5. Выбирается вершина 2:

![image](https://user-images.githubusercontent.com/55274498/138594216-77d49cf0-f6fa-489a-8649-5b943fe98e56.png)

6. Далее получается, что нужно добавить в остов вершину 7:

![image](https://user-images.githubusercontent.com/55274498/138594228-662878c9-779b-4dca-812a-4291d585b865.png)

7. Последним шагом добавляется вершина 6:

![image](https://user-images.githubusercontent.com/55274498/138594264-0ef8b1d2-d8f6-4215-9d99-565c4324dcb9.png)

Так было получено минимальное остовное дерево

Суммарная длина ребер: 7+12+11+10+9+14 = **63**

### Алгоритм Краскала

![image](https://user-images.githubusercontent.com/55274498/138594320-e35ad45c-c863-4481-9fb2-fce426f35d41.png)

#### Объяснение алгоритма:
Вначале список ребер сортируется по их весу. Затем на каждой итерации объединяются деревья, если в результате объединения не появится цикл.

#### Список ребер:

|x|1|1|1|1|2|2|2|3|3|3|4|4|5|5|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|x|2|3|5|7|3|4|7|4|5|7|5|6|6|7|
|Вес|12|10|11|18|13|14|7|9|13|16|15|14|15|14|

### Моделирование

#### Сортировка списка

|x|2|3|1|1|1|2|3|2|4|5|4|5|3|1|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|x|7|4|3|5|2|3|5|4|6|7|5|6|7|7|
|Вес|7|9|10|11|12|13|13|14|14|14|15|15|16|18|

1. Выбираем первое ребро 2-7 в списке:

![image](https://user-images.githubusercontent.com/55274498/138594594-fa377616-c75f-44c3-b7a9-c62e48f85519.png)

2. Рассматриваем ребро 3-4, оно не образует цикла с предыдущим. Значит добавляем его:

![image](https://user-images.githubusercontent.com/55274498/138594615-8f6c5e37-cb3b-48de-914a-e8d6ace8dc15.png)

3. Рассматриваем ребро 1-3, оно не образует цикла при добавлении. Значит добавляем его:

![image](https://user-images.githubusercontent.com/55274498/138594622-51342d5c-b3ea-4d52-96f5-3637213fe135.png)

4. Рассматриваем ребро 1-5, оно не образует цикла при добавлении. Значит добавляем его:

![image](https://user-images.githubusercontent.com/55274498/138594641-df480848-9923-4c3e-a0a5-8b70ed593499.png)

5. Рассматриваем ребро 1-2, оно не образует цикла при добавлении. Значит добавляем его:

![image](https://user-images.githubusercontent.com/55274498/138594657-3f00dda7-8365-4103-8355-00da107f5aba.png)

6. Рассматриваем ребро 4-6, оно не образует цикла при добавлении. Значит добавляем его:

![image](https://user-images.githubusercontent.com/55274498/138594662-5bf7be43-731d-47fe-b0c7-f3b4c6909a8f.png)

Дальше мы ничего не сможем добавить. Алгоритм закончен.

Длина остова:7+9+14+10+12+11=63

### Вывод:
В обоих алгоритмах мы получили минимальное остовое дерево с длиной 36. При этом, временная сложность алгоритма Прима O(V2), где V-количество вершин(так как граф был дан в виде матрицы смежности). При использовании быстрых алгоритмов сортировок временная сложность алгоритма Краскала будет составлять O(N*logN), где N-количество ребер в графе.

### Используемая литература
Новиков Ф. А. (2008) с. 327-330













